<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Soul‑Lite — Dungeon (No-Glow Cartoon)</title>
  <style>
  /* Flat cartoon UI — no glow, no blur, thick ink outlines */
  :root{
    --ink:#110a1c; --panel:#2b2152; --panel2:#362a68; --line:#3b2f75; --text:#f5f2ff; --accent:#ff8fd3; --gold:#ffd45f; --heart:#ff6b7d;
  }
  html, body {
    height: 100%;
    margin: 0;
    background: radial-gradient(circle at top, #3b2a6d 0%, #1a163b 55%, #080414 100%);
    color: var(--text);
    font-family: "Nunito", "Baloo 2", Inter, system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial;
  }
  canvas { display:block; width: 100vw; height: 100vh; image-rendering: pixelated; }

  #ui {
    position: fixed;
    inset: 0;
    pointer-events: none;
    font-weight: 800;
    letter-spacing: 0.4px;
  }

  #centerTip {
    position: absolute;
    left: 50%;
    top: 32px;
    transform: translateX(-50%);
    text-align: center;
    font-size: 16px;
    letter-spacing: 0.8px;
    text-transform: none;
    text-shadow: 0 3px 0 rgba(0,0,0,0.45);
    pointer-events: none;
    white-space: pre-line;
    font-weight: 700;
  }
  #centerTip.death {
    top: 50%;
    transform: translate(-50%, -50%);
  }

  #topBar {
    position: absolute;
    top: 18px;
    left: 22px;
    right: 22px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    pointer-events: none;
  }

  #waveLabel {
    font-size: 20px;
    letter-spacing: 2px;
    text-transform: uppercase;
    display: flex;
    gap: 6px;
    align-items: baseline;
  }
  #waveLabel span { font-size: 26px; }

  #topRight { display:flex; gap:20px; font-size: 14px; text-transform: uppercase; letter-spacing: 1.4px; opacity: 0.85; }
  #topRight span strong { font-size: 18px; letter-spacing: 1.8px; color: var(--text); }

  #hud {
    position: absolute;
    left: 22px;
    top: 66px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    width: 220px;
    pointer-events: none;
  }

  .stat-track { display:flex; flex-direction:column; gap:6px; }
  .stat-track .label { font-size: 12px; text-transform: uppercase; letter-spacing: 1.8px; opacity: 0.7; }
  .stat-track .bar-row { display:flex; align-items:center; gap:12px; }
  .stat-track .value { font-size: 14px; letter-spacing: 1px; opacity: 0.9; }

  .stat-bar {
    flex: 1;
    height: 14px;
    border: 3px solid var(--ink);
    border-radius: 6px;
    background: #1b1633;
    box-shadow: inset 0 -2px 0 rgba(0,0,0,0.5);
    overflow: hidden;
    position: relative;
  }
  .fill {
    height: 100%;
    width: 0;
    transition: width .12s ease-out;
    image-rendering: pixelated;
    background-size: 16px 16px;
    background-image: linear-gradient(90deg, rgba(255,255,255,0.15) 0 8px, rgba(0,0,0,0.12) 8px 16px);
  }
  .fill.hp { background-color: var(--heart); }
  .fill.dash { background-color: var(--accent); }

  #weaponList {
    position: absolute;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 14px;
    pointer-events: none;
  }
  .weapon {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    padding: 10px 14px;
    min-width: 96px;
    background: rgba(7, 5, 18, 0.55);
    border: 3px solid rgba(0,0,0,0.4);
    border-radius: 12px;
    box-shadow: 0 4px 0 rgba(0,0,0,0.45);
    transition: transform .16s ease-out, border-color .16s ease-out, box-shadow .16s ease-out;
  }
  .weapon.active {
    transform: translateY(-8px);
    border-color: var(--accent);
    box-shadow: 0 8px 0 rgba(0,0,0,0.55);
  }
  .weapon-thumb {
    width: 68px;
    height: 34px;
    border-radius: 8px;
    border: 3px solid var(--ink);
    background: linear-gradient(135deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 45%), var(--thumb-color);
    image-rendering: pixelated;
  }
  .weapon-name { font-size: 13px; letter-spacing: 1px; text-transform: uppercase; text-align: center; }
  .weapon-key { font-size: 11px; letter-spacing: 1.4px; opacity: 0.6; text-transform: uppercase; }

  #pause {
    position: absolute;
    bottom: 18px;
    right: 22px;
    color: #c3c9e8;
    font-size: 13px;
    letter-spacing: 1.2px;
    text-transform: uppercase;
    pointer-events: none;
  }

  #levelIndicator {
    position: absolute;
    left: 22px;
    bottom: 24px;
    pointer-events: none;
    font-size: 13px;
    letter-spacing: 1.2px;
    text-transform: uppercase;
    opacity: 0.8;
  }

  #testStatus {
    position: absolute;
    left: 22px;
    bottom: 62px;
    pointer-events: none;
    font-size: 12px;
    letter-spacing: 1.2px;
    text-transform: uppercase;
    opacity: 0.7;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui">
  <div id="topBar">
    <div id="waveLabel">Волна <span id="waveText">1</span></div>
    <div id="topRight">
      <span>Очки <strong id="coinsText">0</strong></span>
      <span>Время <strong id="timeText">00:00</strong></span>
    </div>
  </div>
  <div id="hud">
    <div class="stat-track hp">
      <div class="label">Здоровье</div>
      <div class="bar-row">
        <div class="stat-bar">
          <div id="hpFill" class="fill hp" style="width:100%"></div>
        </div>
        <div class="value" id="hpValue">6 / 6</div>
      </div>
    </div>
    <div class="stat-track dash">
      <div class="label">Рывок</div>
      <div class="bar-row">
        <div class="stat-bar">
          <div id="dashFill" class="fill dash" style="width:100%"></div>
        </div>
      </div>
    </div>
  </div>
  <div id="weaponList"></div>
  <div id="levelIndicator">Ур. 1 — XP 0/50</div>
  <div id="pause">[P] пауза • [1–4] оружие • [Q/E] смена • [Space] рывок</div>
  <div id="centerTip"></div>
  <div id="testStatus" style="display:none"></div>
</div>
<script>
(() => {
  // ===== Helpers =====
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const rand = (a=1, b=null) => (b==null ? Math.random()*a : a + Math.random()*(b-a));
  const rndInt = (a, b) => Math.floor(a + Math.random()*(b-a+1));
  const TAU = Math.PI * 2;
  const now = () => performance.now();
  const angNorm = (a) => ((a + Math.PI) % (2*Math.PI) + (2*Math.PI)) % (2*Math.PI) - Math.PI; // [-PI, PI)
  const angDiff = (a,b) => Math.abs(angNorm(b-a));
  const angleLerp = (a,b,t) => { let d=angNorm(b-a); return a + d*clamp(t,0,1); };
  const shadeHex = (hex, pct) => {
    if (!/^#([0-9a-f]{6})$/i.test(hex)) return hex;
    const num = parseInt(hex.slice(1), 16);
    let r = (num >> 16) & 0xff;
    let g = (num >> 8) & 0xff;
    let b = num & 0xff;
    r = Math.round(clamp(r + 255*pct, 0, 255));
    g = Math.round(clamp(g + 255*pct, 0, 255));
    b = Math.round(clamp(b + 255*pct, 0, 255));
    return '#' + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1);
  };

  // ===== Canvas =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));

  // ===== UI Refs =====
  const hpFill = document.getElementById('hpFill');
  const hpValue = document.getElementById('hpValue');
  const coinsText = document.getElementById('coinsText');
  const timeText = document.getElementById('timeText');
  const dashFill = document.getElementById('dashFill');
  const waveText = document.getElementById('waveText');
  const centerTip = document.getElementById('centerTip');
  const weaponList = document.getElementById('weaponList');
  const levelIndicator = document.getElementById('levelIndicator');
  const testStatus = document.getElementById('testStatus');

  function resize() {
    const w = window.innerWidth, h = window.innerHeight;
    canvas.width = w * DPR; canvas.height = h * DPR; canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    buildDungeonGeometry();
  }
  window.addEventListener('resize', resize);
  window.addEventListener('contextmenu', e=>e.preventDefault());

  // ===== Audio (safe no-op if blocked) =====
  let audioCtx = null; const SFX = {
    shot(freq=420, t=0.06) { if (!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.value=freq; g.gain.setValueAtTime(.10,audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(.0001, audioCtx.currentTime+t); o.connect(g).connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+t); },
    boom(){ if (!audioCtx) return; const b=audioCtx.createBuffer(1, 44100*.25, 44100); const d=b.getChannelData(0); for (let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,2);} const s=audioCtx.createBufferSource(); const g=audioCtx.createGain(); g.gain.value=.25; s.buffer=b; s.connect(g).connect(audioCtx.destination); s.start(); },
    hit(){ if (!audioCtx) return; this.shot(180,.04); }
  };
  window.addEventListener('pointerdown', () => { if (!audioCtx) { audioCtx = new (window.AudioContext||window.webkitAudioContext)(); } }, { once: true });

  // ===== Game State =====
  const state = { running: true, time: 0, score: 0, lastSpawn: 0, spawnRate: 1200, roomId: 0, killsInRoom: 0, bossActive:false, bootAimMs: 1200,
    xp: 0, level: 1, nextXp: 50 };

  // ===== Input (layout‑independent via e.code) =====
  const codes = new Set(); // physical keys like 'KeyW', 'KeyA', …
  const mouse = { x: 0, y: 0, down: false };
  let usingKbAim = false; let pointerLocked = false; let mouseMoved = false; let mouseSens = 0.004;

  window.addEventListener('keydown', (e) => {
    codes.add(e.code);
    if (["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.code)) e.preventDefault();
    if (e.code==='KeyP') togglePause();
    if (e.code==='KeyL') togglePointerLock();
    if (e.code==='KeyF') { settings.autoFire = !settings.autoFire; flashTip(`Авто-огонь: ${settings.autoFire?'ВКЛ':'ВЫКЛ'}`); }
    if (e.code==='KeyX') { settings.aimAssist = !settings.aimAssist; flashTip(`Aim‑assist: ${settings.aimAssist?'ВКЛ':'ВЫКЛ'}`); }
    if (e.code.startsWith('Arrow')) usingKbAim = true;
  });
  window.addEventListener('keyup',   (e) => { codes.delete(e.code); });
  window.addEventListener('blur',    ()=>{ codes.clear(); });
  function togglePointerLock(){ if (!pointerLocked) canvas.requestPointerLock?.(); else document.exitPointerLock?.(); }
  document.addEventListener('pointerlockchange', ()=>{ pointerLocked = (document.pointerLockElement===canvas); });
  canvas.addEventListener('pointermove', e => {
    const r=canvas.getBoundingClientRect();
    if (pointerLocked) { player.angle += e.movementX * mouseSens; mouseMoved=true; }
    else { mouse.x = (e.clientX - r.left); mouse.y = (e.clientY - r.top); mouseMoved=true; usingKbAim=false; player.angle = Math.atan2(mouse.y - player.y, mouse.x - player.x); }
  });
  canvas.addEventListener('pointerdown', () => mouse.down = true);
  window.addEventListener('pointerup',   () => mouse.down = false);

  // ===== Entities =====
  const bullets = [], enemies = [], particles = [], xpDrops = [];

  // ===== Palette (flat, no glow) =====
  const C = { ink:'#111318', white:'#ffffff', floor1:'#232731', floor2:'#1e2230', wall:'#2b3140', wallLine:'#0f1218', ui:'#5fb3ff', p1:'#cfe4ff', visor:'#9ed1ff', pistol:'#5fb3ff', shot:'#5fb3ff', mint:'#58d1a8', blue:'#5fa6ff', pink:'#ff8aa1', gold:'#d9ba4f', violet:'#b192ff', red:'#e76f51' };

  // ===== Primitives =====
  function roundRect(x,y,w,h,r){ const rr=Math.min(r, Math.min(w,h)/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); }
  function capsule(x,y,len,r,angle){ ctx.save(); ctx.translate(x,y); ctx.rotate(angle); ctx.beginPath(); ctx.moveTo(0,-r); ctx.arcTo(len,-r,len,r,r); ctx.arcTo(len,r,0,r,r); ctx.arcTo(0,r,0,-r,r); ctx.arcTo(0,-r,len,-r,r); ctx.closePath(); ctx.restore(); }

  // ===== Player =====
  const player = { x: canvas.clientWidth/2, y: canvas.clientHeight/2, vx:0, vy:0, r:16, speed: 240, angle: 0, hp:6, maxHp:6, dashCd:0, iTimer:0, weaponIdx:0, lastShot:0,
                   accel: 4200, decel: 5200, deadzone: 0.1 };
  const settings = { autoFire:true, aimAssist:true,
    aimRange:640,           // радиус ассиста
    stickyMs:220,           // удержание цели
    blend:1.0,              // (не используется для выстрела; оставлено для совместимости)
    losBlock:true,          // учитывать «линию видимости»
    followStrength: 999,    // не используется (сохранено для совместимости)
    assistLeadFactor: 0.7   // насколько учитывать упреждение (0..1)
  };

  // ===== Weapons =====
  const weapons = [
    { key:'1', name:'Пистолет', color:C.pistol, auto:false, rpm: 300, dmg:2,   bulletSpeed: 560, life: 1200, spread: 1,  pellets:1, pierce:0, radius:4, recoil: 4,  sfx:()=>SFX.shot(420) },
    { key:'2', name:'Дробовик', color:C.mint,   auto:false, rpm: 70,  dmg:1.2, bulletSpeed: 520, life: 750,  spread: 12, pellets:8, pierce:0, radius:4, recoil: 8,  sfx:()=>SFX.shot(280) },
    { key:'3', name:'ПП',      color:C.blue,   auto:true,  rpm: 720, dmg:1.2, bulletSpeed: 600, life: 900,  spread: 4,  pellets:1, pierce:0, radius:3, recoil: 2,  sfx:()=>SFX.shot(520) },
    { key:'4', name:'Ракета',  color:C.violet, auto:false, rpm: 60,  dmg:5,   bulletSpeed: 420, life: 2200, spread: 2,  pellets:1, pierce:0, radius:6, recoil: 12, explosive: 80, sfx:()=>SFX.shot(160) },
  ];
  function renderWeaponList(){
    if (!weaponList) return;
    weaponList.innerHTML='';
    weapons.forEach((w,i)=>{
      const div=document.createElement('div');
      div.className='weapon'+(i===player.weaponIdx?' active':'');
      div.style.setProperty('--thumb-color', `linear-gradient(180deg, ${w.color} 0%, ${shadeHex(w.color,-0.25)} 100%)`);
      const thumb=document.createElement('div');
      thumb.className='weapon-thumb';
      const name=document.createElement('div');
      name.className='weapon-name';
      name.textContent=w.name;
      const key=document.createElement('div');
      key.className='weapon-key';
      key.textContent=w.key;
      div.appendChild(thumb);
      div.appendChild(name);
      div.appendChild(key);
      weaponList.appendChild(div);
    });
  }
  renderWeaponList();

  // ===== Enemies (5 types) + boss =====
  const ALL_TYPES = ['chaser','shooter','brute','dasher','slimer','bomber'];
  let roomTypes = [];
  let ENEMY_ID = 1;

  class Bullet { constructor(x,y, dx,dy, speed, dmg, life, radius, pierce=0, color=C.shot, explosive=0) { const L=Math.hypot(dx,dy)||1; this.x=x; this.y=y; this.vx=dx/L*speed; this.vy=dy/L*speed; this.dmg=dmg; this.life=life; this.r=radius; this.pierce=pierce; this.color=color; this.explosive=explosive; this.dead=false; }
    update(dtMs){ const dt=dtMs/1000; this.x+=this.vx*dt; this.y+=this.vy*dt; this.life-=dtMs; if(this.life<=0) this.dead=true; if(this.x<-60||this.y<-60||this.x>canvas.clientWidth+60||this.y>canvas.clientHeight+60) this.dead=true; }
    draw(){ ctx.fillStyle=this.color; ctx.strokeStyle=C.ink; ctx.lineWidth=3; capsule(this.x,this.y, this.r*3.5, this.r, Math.atan2(this.vy,this.vx)); ctx.fill(); ctx.stroke(); }
  }

  class Enemy { constructor(x,y, type='chaser') { this.id=ENEMY_ID++; this.x=x; this.y=y; this.vx=0; this.vy=0; this.type=type; this.r=16; this.dead=false; this.cd=0; this.hp=3; this.speed=90; this.extra=0; this.small=false; this.init(); }
    init(){
      if(this.type==='chaser'){ this.hp=3; this.speed=100; }
      if(this.type==='shooter'){ this.hp=4; this.speed=70; this.cd=600; }
      if(this.type==='brute'){ this.hp=8; this.speed=60; this.r=18; }
      if(this.type==='dasher'){ this.hp=3; this.speed=80; this.cd=0; }
      if(this.type==='slimer'){ this.hp=5; this.speed=75; this.extra=2; }
      if(this.type==='slimelet'){ this.hp=1; this.speed=110; this.r=12; this.small=true; }
      if(this.type==='bomber'){ this.hp=2; this.speed=95; }
    }
    update(dt){
      const px=this.x, py=this.y;
      const dx=player.x-this.x, dy=player.y-this.y, d=Math.hypot(dx,dy)||1, nx=dx/d, ny=dy/d;
      if(this.type==='shooter'){ this.cd-=dt*1000; if(this.cd<=0 && d<520){ this.cd=900; enemyShoot(this.x,this.y,nx,ny); } this.x+=nx*this.speed*0.4*dt; this.y+=ny*this.speed*0.4*dt; }
      else if(this.type==='dasher'){ this.cd-=dt*1000; if(this.cd<=0 && d<360){ this.cd=1300; this.x+=nx*380*dt; this.y+=ny*380*dt; } else { this.x+=nx*this.speed*dt; this.y+=ny*this.speed*dt; } }
      else { this.x+=nx*this.speed*dt; this.y+=ny*this.speed*dt; }
      if(this.type==='bomber' && d<this.r+player.r+2){ explode(this.x,this.y,80,2.8); xpDrops.push(new XpOrb(this.x, this.y, xpValueFor(this.type))); this.dead=true; }
      // estimate velocity
      const inv = dt>0? (1/dt): 0; this.vx=(this.x-px)*inv; this.vy=(this.y-py)*inv;
    }
    draw(){
      ctx.strokeStyle=C.ink; ctx.lineWidth=4; ctx.fillStyle=enemyColor(this.type);
      roundRect(this.x-18, this.y-16, 36, 32, 10); ctx.fill(); ctx.stroke();
      // eyes
      ctx.fillStyle=C.white; ctx.strokeStyle=C.ink; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(this.x-6, this.y-3, 4,0,TAU); ctx.arc(this.x+6, this.y-3, 4,0,TAU); ctx.fill(); ctx.stroke();
      const ang=Math.atan2(player.y-this.y, player.x-this.x); const px=Math.cos(ang)*1.5, py=Math.sin(ang)*1.5; ctx.fillStyle=C.ink; ctx.beginPath(); ctx.arc(this.x-6+px, this.y-3+py, 2,0,TAU); ctx.arc(this.x+6+px, this.y-3+py, 2,0,TAU); ctx.fill();
      // hp bar small
      const maxHp = (this.type==='brute'?8:this.type==='shooter'?4:this.type==='slimer'?5:this.type==='bomber'?2:this.type==='dasher'?3:3); const ratio=clamp(this.hp/maxHp,0,1);
      ctx.fillStyle='#12151c'; ctx.fillRect(this.x-14,this.y-22,28,5); ctx.fillStyle=C.white; ctx.fillRect(this.x-14,this.y-22,28*ratio,5);
    }
  }

  class Boss { constructor(){ this.type='boss'; this.r=28; this.x=canvas.clientWidth/2; this.y=80; this.hp=100; this.speed=55; this.cdShoot=1200; this.cdSummon=2500; this.vx=0; this.vy=0; }
    update(dt){ const px=this.x, py=this.y; const dx=player.x-this.x, dy=player.y-this.y, d=Math.hypot(dx,dy)||1; const nx=dx/d, ny=dy/d; this.x+=nx*this.speed*dt; this.y+=ny*this.speed*dt; this.vx=(this.x-px)/(dt||1); this.vy=(this.y-py)/(dt||1); this.cdShoot-=dt*1000; this.cdSummon-=dt*1000; if(this.cdShoot<=0){ this.cdShoot=800; radialShot(this.x,this.y,10); } if(this.cdSummon<=0){ this.cdSummon=3500; summonMinions(this.x,this.y); } }
    draw(){ ctx.strokeStyle=C.ink; ctx.lineWidth=5; ctx.fillStyle='#bdc6d9'; roundRect(this.x-28,this.y-26,56,52,14); ctx.fill(); ctx.stroke(); // crown
      ctx.fillStyle='#c9a227'; ctx.strokeStyle=C.ink; roundRect(this.x-18,this.y-38,36,12,4); ctx.fill(); ctx.stroke(); // face
      ctx.fillStyle=C.white; ctx.strokeStyle=C.ink; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(this.x-8, this.y-8, 6,0,TAU); ctx.arc(this.x+8,this.y-8,6,0,TAU); ctx.fill(); ctx.stroke(); ctx.fillStyle=C.ink; ctx.beginPath(); ctx.arc(this.x-8, this.y-8, 3,0,TAU); ctx.arc(this.x+8,this.y-8,3,0,TAU); ctx.fill(); // hp bar
      const ratio=clamp(this.hp/100,0,1); ctx.fillStyle='#12151c'; ctx.fillRect(this.x-30,this.y-42,60,6); ctx.fillStyle=C.red; ctx.fillRect(this.x-30,this.y-42,60*ratio,6); }
  }

  function enemyColor(type){ if(type==='brute') return C.pink; if(type==='shooter') return C.gold; if(type==='dasher') return '#88b2ff'; if(type==='slimer'||type==='slimelet') return C.mint; if(type==='bomber') return '#d77f76'; return '#9fb3ff'; }

  function enemyShoot(x,y,nx,ny){ const b=new Bullet(x,y,nx,ny, 220,1,2600,5,0,C.gold); b.enemy=true; bullets.push(b); }
  function radialShot(x,y,n=8){ for(let i=0;i<n;i++){ const a=i/n*TAU; const b=new Bullet(x,y,Math.cos(a),Math.sin(a), 260,1.2,2400,5,0,'#d37f5f'); b.enemy=true; bullets.push(b);} }
  function summonMinions(x,y){ for(let i=0;i<3;i++){ const ang=rand(0,TAU); const r=rand(40,90); enemies.push(new Enemy(x+Math.cos(ang)*r, y+Math.sin(ang)*r, roomTypes[rndInt(0,roomTypes.length-1)])); } }

  let boss=null;

  function startNewRoom(){
    bullets.length=0; enemies.length=0; particles.length=0; xpDrops.length=0; state.killsInRoom=0; state.bossActive=false; boss=null; state.roomId++;
    const pool=[...ALL_TYPES]; roomTypes=[]; while(roomTypes.length<5 && pool.length){ const i=rndInt(0,pool.length-1); roomTypes.push(pool.splice(i,1)[0]); }
    for(let i=0;i<6;i++) spawnEnemy();
    setTip(`Комната ${state.roomId}\nТипы: ${roomTypes.join(', ')}`);
    setTimeout(()=>{ clearTipIfNonDeath(); },1500);
  }

  // ===== Dungeon (flat tiles, cave walls) =====
  const TILE = 56; let dungeon = { cracks:[], pillars:[], rim:[] };
  function buildDungeonGeometry(){
    dungeon = { cracks:[], pillars:[], rim:[] };
    const W = canvas.clientWidth, H = canvas.clientHeight;
    const N = Math.floor((W*H)/120000);
    for(let i=0;i<N;i++){ dungeon.cracks.push({x:rand(0,W), y:rand(0,H), len:rand(30,120), ang:rand(0,TAU)}); }
    const P = Math.max(2, Math.floor(Math.min(W,H)/260));
    for(let i=0;i<P;i++){ dungeon.pillars.push({x:rand(TILE*2,W-TILE*2), y:rand(TILE*2,H-TILE*2), r:rand(18,26)}); }
    const seg=18; for(let i=0;i<seg;i++){ const a=i/seg*TAU; const r=0.94 + Math.sin(i*1.3)*0.03 + Math.cos(i*0.7)*0.02; dungeon.rim.push({a, r}); }
  }

  function drawDungeon(){
    const W = canvas.clientWidth, H = canvas.clientHeight;
    for(let y=0;y<H;y+=TILE){ for(let x=0;x<W;x+=TILE){ ctx.fillStyle=((x/TILE + y/TILE)&1)? C.floor1 : C.floor2; ctx.fillRect(x,y,TILE,TILE); ctx.strokeStyle='#161922'; ctx.lineWidth=1; ctx.strokeRect(x+0.5,y+0.5,TILE-1,TILE-1); ctx.beginPath(); ctx.moveTo(x+10,y+TILE/2); ctx.lineTo(x+TILE-10,y+TILE/2); ctx.moveTo(x+TILE/2,y+10); ctx.lineTo(x+TILE/2,y+TILE-10); ctx.stroke(); }}
    ctx.strokeStyle='#141720'; ctx.lineWidth=2; ctx.lineCap='round';
    for(const c of dungeon.cracks){ ctx.beginPath(); ctx.moveTo(c.x, c.y); ctx.lineTo(c.x + Math.cos(c.ang)*c.len, c.y + Math.sin(c.ang)*c.len); ctx.stroke(); }
    ctx.fillStyle=C.wall; ctx.strokeStyle=C.wallLine; ctx.lineWidth=4; ctx.beginPath();
    for(let i=0;i<dungeon.rim.length;i++){ const r=dungeon.rim[i].r; const a=dungeon.rim[i].a; const x = (canvas.clientWidth/2) + Math.cos(a)* (Math.min(canvas.clientWidth,canvas.clientHeight)/2 * r); const y = (canvas.clientHeight/2) + Math.sin(a)* (Math.min(canvas.clientWidth,canvas.clientHeight)/2 * r); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
    ctx.closePath(); ctx.stroke();
    ctx.fillStyle=C.wall; ctx.strokeStyle=C.wallLine; ctx.lineWidth=4; for(const p of dungeon.pillars){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,TAU); ctx.fill(); ctx.stroke(); }
  }

  function spawnEnemy(){
    const w = canvas.clientWidth, h = canvas.clientHeight; const side=rndInt(0,3); let x=0,y=0; if(side===0){x=rand(0,w); y=-20;} else if(side===1){x=w+20; y=rand(0,h);} else if(side===2){x=rand(0,w); y=h+20;} else {x=-20; y=rand(0,h);} 
    const type = roomTypes[rndInt(0,roomTypes.length-1)]; enemies.push(new Enemy(x,y,type));
  }

  // ===== Aim Assist (nearest) — predictive lead + LOS =====
  let aimState = { id:null, until:0 };

  function segmentCircleIntersects(x1,y1,x2,y2, cx,cy,r){
    const dx=x2-x1, dy=y2-y1; const fx=x1-cx, fy=y1-cy; const a=dx*dx+dy*dy; const b=2*(fx*dx+fy*dy); const c=(fx*fx+fy*fy)-r*r; let disc=b*b-4*a*c; if(disc<0) return false; disc=Math.sqrt(disc); let t1=(-b-disc)/(2*a), t2=(-b+disc)/(2*a); return (t1>=0&&t1<=1)||(t2>=0&&t2<=1);
  }
  function hasLOS(tx,ty){ if(!settings.losBlock) return true; for(const p of dungeon.pillars){ if(segmentCircleIntersects(player.x,player.y, tx,ty, p.x,p.y,p.r+6)) return false; } return true; }
  function solveIntercept(px,py, tx,ty, tvx,tvy, projSpeed){
    const rx=tx-px, ry=ty-py; const vv=tvx*tvx+tvy*tvy; const rv=rx*tvx+ry*tvy; const rr=rx*rx+ry*ry; const s2=projSpeed*projSpeed;
    const A = vv - s2; const B = 2*rv; const C = rr;
    let t=null;
    if (Math.abs(A) < 1e-6){ if (Math.abs(B) < 1e-6) return null; t = -C/B; if (t<=0) return null; }
    else { const D = B*B - 4*A*C; if (D < 0) return null; const sqrtD=Math.sqrt(D); const t1=(-B - sqrtD)/(2*A); const t2=(-B + sqrtD)/(2*A); const cand=[t1,t2].filter(x=>x>0); if(!cand.length) return null; t=Math.min.apply(null,cand); }
    return t;
  }
  function computeAssist(baseAngle, weapon){
    let best=null; let bestD=Infinity; let bestId=null;
    // соберём кандидатов: все мобы + БОСС
    const candidates = [];
    for (const e of enemies){ candidates.push({ id:e.id, x:e.x, y:e.y, vx:e.vx||0, vy:e.vy||0, r:e.r||16, isBoss:false }); }
    if (boss){ candidates.push({ id:'boss', x:boss.x, y:boss.y, vx:boss.vx||0, vy:boss.vy||0, r:boss.r||28, isBoss:true }); }

    for(const t of candidates){
      const dx=t.x-player.x, dy=t.y-player.y; const d=Math.hypot(dx,dy);
      const extraRange = t.isBoss ? 120 : 0; // босс крупный — чуть увеличим радиус захвата
      if(d>settings.aimRange + extraRange) continue; 
      if(!hasLOS(t.x,t.y)) continue; 
      if(d<bestD){ bestD=d; best=t; }
    }
    if(!best) return null;

    // predictive lead
    const tt = solveIntercept(player.x,player.y, best.x,best.y, best.vx, best.vy, weapons[player.weaponIdx].bulletSpeed);
    let tx=best.x, ty=best.y; if(tt!=null && tt<1.2){ tx += best.vx*tt; ty += best.vy*tt; }
    const leadAngle = Math.atan2(ty-player.y, tx-player.x);
    const straightAngle = Math.atan2(best.y-player.y, best.x-player.x);
    bestId = best.id;
    return { leadAngle, straightAngle, lockId: bestId };
  }

  // ===== Movement helpers =====
  function getMoveIntent(){
    let ix=0, iy=0; if(codes.has('KeyW')) iy-=1; if(codes.has('KeyS')) iy+=1; if(codes.has('KeyA')) ix-=1; if(codes.has('KeyD')) ix+=1;
    let mag=Math.hypot(ix,iy);
    if (mag < player.deadzone) { ix=0; iy=0; mag=0; }
    if (mag>0){ ix/=mag; iy/=mag; }
    return {ix, iy, mag};
  }
  function doDash(force=360){
    if (player.dashCd>0) return;
    const mv = getMoveIntent();
    let dx, dy;
    if (mv.mag>0){ dx=mv.ix; dy=mv.iy; }
    else {
      const vlen = Math.hypot(player.vx, player.vy);
      if (vlen>20){ dx=player.vx/vlen; dy=player.vy/vlen; }
      else { dx=Math.cos(player.angle); dy=Math.sin(player.angle); }
    }
    player.x = clamp(player.x + dx*force, player.r, canvas.clientWidth - player.r);
    player.y = clamp(player.y + dy*force, player.r, canvas.clientHeight - player.r);
    player.dashCd = 1000; player.iTimer = 200;
  }

  // ===== Instant aim helper (no smoothing) =====
  function applyAimAssistInstant(){
    if (!settings.aimAssist) return;
    const resA = computeAssist(player.angle, weapons[player.weaponIdx]);
    if (resA){
      const targetAng = angleLerp(resA.straightAngle, resA.leadAngle, settings.assistLeadFactor);
      player.angle = targetAng; // мгновенно ставим угол
    }
  }

  function setTip(text='', death=false){ if(!centerTip) return; if(death){ centerTip.classList.add('death'); } else { centerTip.classList.remove('death'); } centerTip.textContent = text; }
  function clearTipIfNonDeath(){ if(centerTip && !centerTip.classList.contains('death')) setTip(''); }

  // ===== UI boot text =====
  setTip('WASD — движение • Мышь/тачпад — прицел • ЛКМ — огонь • Space — рывок\nРывок идёт в сторону движения (WASD), если стоишь — по взгляду.\n[F] авто‑огонь • [X] ассист • [L] pointer-lock');
  setTimeout(()=>{ clearTipIfNonDeath(); }, 3000);

  function flashTip(txt){ if(!centerTip) return; setTip(txt); setTimeout(()=>{ clearTipIfNonDeath(); }, 1200); }

  function updateHud(){
    // === Health bar ===
    if (hpFill && hpValue){
      const hpRatio = clamp(player.hp / player.maxHp, 0, 1);
      hpFill.style.width = (hpRatio * 100) + '%';
      const hpCurr = Math.max(0, Math.round(player.hp * 10) / 10);
      const hpLabel = Number.isInteger(hpCurr) ? Math.round(hpCurr) : hpCurr.toFixed(1);
      hpValue.textContent = `${hpLabel} / ${player.maxHp}`;
    }

    // === Coins ===
    if (coinsText){ coinsText.textContent = state.score; }

    // === Time ===
    const secs=Math.floor(state.time/1000); const m=(''+Math.floor(secs/60)).padStart(2,'0'); const s=(''+(secs%60)).padStart(2,'0');
    if (timeText){ timeText.textContent = `${m}:${s}`; }

    if (levelIndicator){
      const xpCurr = Math.max(0, Math.round(state.xp));
      levelIndicator.textContent = `Ур. ${state.level} — XP ${xpCurr}/${Math.max(1, Math.round(state.nextXp))}`;
    }

    // === Room / wave info ===
    const waveNumber = Math.max(1, state.roomId);
    if (waveText) waveText.textContent = waveNumber.toString().padStart(2,'0');

    // === Dash cooldown bar ===
    if (dashFill){
      const dashPct = clamp(1 - player.dashCd/1000, 0, 1);
      dashFill.style.width = (dashPct * 100) + '%';
    }

    // === Weapon list active highlight ===
    renderWeaponList();
  }

  // ===== Shooting =====
  function tryShoot(time, force=false){
    const w = weapons[player.weaponIdx];
    const cd = 60000 / w.rpm; if (time - player.lastShot < cd) return; if (!w.auto && !mouse.down && !force) return;

    // Мгновенная установка угла перед выстрелом
    let baseAng = player.angle;
    if (settings.aimAssist){
      const res = computeAssist(baseAng, w);
      if (res){
        const targetAng = angleLerp(res.straightAngle, res.leadAngle, settings.assistLeadFactor);
        baseAng = targetAng; // без плавности
        aimState.id = res.lockId; aimState.until = state.time + settings.stickyMs;
      }
    }

    for (let i=0;i<w.pellets;i++){
      const ang = baseAng + (rand(-w.spread, w.spread) * Math.PI / 180);
      const vx = Math.cos(ang), vy = Math.sin(ang);
      const b = new Bullet(player.x + vx*(player.r+8), player.y + vy*(player.r+8), vx, vy, w.bulletSpeed, w.dmg, w.life, w.radius, w.pierce, w.color, w.explosive||0);
      bullets.push(b);
      for(let k=0;k<2;k++) particles.push(new Particle(player.x+vx*(player.r+8), player.y+vy*(player.r+8), rand(-40,40)+vx*60, rand(-40,40)+vy*60, 220, '#e6e8f0'));
    }
    player.lastShot = time; w.sfx && w.sfx();
  }

  // ===== Damage/Explosion =====
  class Particle { constructor(x,y, vx,vy, life, color) { this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.life=life; this.max=life; this.color=color; } update(dt){ this.x+=this.vx*dt; this.y+=this.vy*dt; this.vx*=0.98; this.vy*=0.98; this.life-=dt*1000; } draw(){ const t=clamp(this.life/this.max,0,1); ctx.globalAlpha=t; ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x, this.y, 2+2*(1-t), 0, TAU); ctx.fill(); ctx.globalAlpha=1; } }
  class XpOrb {
    constructor(x,y,value){ this.x=x; this.y=y; this.vx=rand(-80,80); this.vy=rand(-80,80); this.value=value; this.r=7; }
    update(dt){ this.vx*=0.9; this.vy*=0.9; const dx=player.x-this.x, dy=player.y-this.y; const dist=Math.hypot(dx,dy)||1; if(dist<220){ const pull=(1-dist/220); this.vx += (dx/dist)*pull*220*dt; this.vy += (dy/dist)*pull*220*dt; } this.x += this.vx*dt; this.y += this.vy*dt; }
    draw(){ ctx.save(); ctx.translate(this.x,this.y); const g=ctx.createRadialGradient(0,0,2,0,0,this.r+2); g.addColorStop(0,'#fff1b2'); g.addColorStop(1,'#d7a943'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,this.r+2,0,TAU); ctx.fill(); ctx.strokeStyle='rgba(17,10,28,0.7)'; ctx.lineWidth=3; ctx.stroke(); ctx.restore(); }
  }

  function xpValueFor(type){ if(type==='brute') return 16; if(type==='shooter') return 12; if(type==='dasher') return 12; if(type==='bomber') return 14; if(type==='slimer') return 14; if(type==='slimelet') return 5; return 10; }
  function grantXp(amount){ state.xp += amount; while(state.xp >= state.nextXp){ state.xp -= state.nextXp; state.level += 1; state.nextXp = Math.round(state.nextXp * 1.2 + 10); flashTip(`Новый уровень: ${state.level}!`); } for(let i=0;i<6;i++){ particles.push(new Particle(player.x, player.y, rand(-120,120), rand(-120,120), 260, '#ffe89a')); } }

  function damageEnemy(e, dmg){ e.hp -= dmg; SFX.hit(); for(let i=0;i<4;i++){ particles.push(new Particle(e.x, e.y, rand(-80,80), rand(-80,80), 320, '#e6e8f0')); } if (e.hp<=0){ e.dead=true; state.score += 10; state.killsInRoom++; xpDrops.push(new XpOrb(e.x+rand(-6,6), e.y+rand(-6,6), xpValueFor(e.type))); if(e.type==='slimer'){ for(let i=0;i<2;i++){ enemies.push(new Enemy(e.x+rand(-12,12), e.y+rand(-12,12), 'slimelet')); } } }
  }
  function explode(x,y,r, baseDmg){ SFX.boom(); for(let i=0;i<22;i++){ particles.push(new Particle(x, y, Math.cos(i/22*TAU)*rand(40,200), Math.sin(i/22*TAU)*rand(40,200), 600, '#e6e8f0')); } enemies.forEach(e=>{ const d=Math.hypot(e.x-x, e.y-y); if(d<r){ const fall = 1 - d/r; damageEnemy(e, baseDmg*(.5+fall)); }}); }

  // ===== Loop =====
  function togglePause(){
    state.running = !state.running;
    if (!state.running) {
      setTip('Пауза — [P] продолжить');
    } else {
      clearTipIfNonDeath();
    }
  }

  let last = now();
  function frame(){
    const w = canvas.clientWidth, h = canvas.clientHeight; const tnow = now(); let dt = tnow - last; last = tnow; dt = Math.min(28, dt);

    if (state.running){ state.time += dt; player.dashCd = Math.max(0, player.dashCd - dt); player.iTimer = Math.max(0, player.iTimer - dt);
      // ===== Movement (physics‑based, framerate‑independent) =====
      const mv = getMoveIntent();
      const targetVx = mv.ix * player.speed;
      const targetVy = mv.iy * player.speed;
      const ax = targetVx - player.vx;
      const ay = targetVy - player.vy;
      const aLen = Math.hypot(ax, ay);
      const maxStep = player.accel * (dt/1000);
      if (aLen > maxStep) {
        player.vx += ax / aLen * maxStep;
        player.vy += ay / aLen * maxStep;
      } else {
        player.vx = targetVx;
        player.vy = targetVy;
      }
      if (mv.mag===0){
        const vLen = Math.hypot(player.vx, player.vy);
        const dec = player.decel * (dt/1000);
        if (vLen <= dec) { player.vx=0; player.vy=0; }
        else { player.vx -= (player.vx / vLen) * dec; player.vy -= (player.vy / vLen) * dec; }
      }
      player.x = clamp(player.x + player.vx*dt/1000, player.r, w-player.r);
      player.y = clamp(player.y + player.vy*dt/1000, player.r, h-player.r);

      // ===== Instant aim (no smoothing) =====
      applyAimAssistInstant();

      // Manual rotate helpers (arrows)
      if (codes.has('ArrowLeft'))  { player.angle -= 2.6 * dt/1000; }
      if (codes.has('ArrowRight')) { player.angle += 2.6 * dt/1000; }
      if (state.time < state.bootAimMs && !mouseMoved && !usingKbAim) { player.angle = Math.atan2(h/2 - player.y, w/2 - player.x); }
      mouseMoved=false;

      // Dash (toward movement, fallback to facing)
      if (codes.has('Space')) { doDash(360); }

      // Auto‑fire: only if есть цель по ассисту
      if (settings.autoFire){ const res = computeAssist(player.angle, weapons[player.weaponIdx]); if (res) tryShoot(tnow, true); }
      if (mouse.down) tryShoot(tnow, false);

      // Bullets
      for (let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.update(dt); if (!b.dead){ if (!b.enemy){ for (let j=enemies.length-1;j>=0;j--){ const e=enemies[j]; const d=Math.hypot(e.x-b.x, e.y-b.y); if (d < e.r + b.r){ if (b.explosive) { explode(b.x,b.y,b.explosive, b.dmg); b.dead=true; break; } damageEnemy(e, b.dmg); if (b.pierce>0) b.pierce--; else { b.dead=true; break; } }} } else { const d = Math.hypot(player.x-b.x, player.y-b.y); if (d < player.r + b.r){ if (player.iTimer<=0){ player.hp -= 1; player.iTimer=300; } b.dead=true; } } } if (b.dead) bullets.splice(i,1); }

      // Enemies
      for (let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.update(dt/1000); const d = Math.hypot(e.x-player.x, e.y-player.y); if (d < e.r + player.r){ if (player.iTimer<=0){ player.hp -= 1; player.iTimer=350; } const nx=(player.x-e.x)/Math.max(1,d), ny=(player.y-e.y)/Math.max(1,d); e.x -= nx*10; e.y -= ny*10; } if (e.dead) enemies.splice(i,1); }

      // Boss spawn condition
      if (!state.bossActive && state.killsInRoom>=18){ boss=new Boss(); state.bossActive=true; }
      if (boss){ boss.update(dt/1000); if (Math.hypot(boss.x-player.x, boss.y-player.y) < boss.r + player.r){ if(player.iTimer<=0){ player.hp-=2; player.iTimer=400; } }
        for (let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; if (!b.enemy){ const d=Math.hypot(boss.x-b.x, boss.y-b.y); if (d < boss.r + b.r){ boss.hp -= b.dmg; bullets.splice(i,1); } } }
        if (boss.hp<=0){ state.score+=100; grantXp(140); boss=null; state.bossActive=false; startNewRoom(); }
      }

      for (let i=xpDrops.length-1;i>=0;i--){ const orb=xpDrops[i]; orb.update(dt/1000); if (Math.hypot(player.x-orb.x, player.y-orb.y) < player.r + orb.r + 4){ grantXp(orb.value); xpDrops.splice(i,1); } }

      // Spawn loop (skip if boss-only)
      state.lastSpawn += dt; const rate = Math.max(420, state.spawnRate - state.time*0.05); if (!state.bossActive && state.lastSpawn > rate){ state.lastSpawn = 0; spawnEnemy(); if (Math.random()<0.25) spawnEnemy(); }

      // Death
      if (player.hp<=0){ state.running=false; const best = Math.max(+(localStorage.getItem('soulLiteBest')||0), state.score); localStorage.setItem('soulLiteBest', best); setTip(`Вы пали.\nСчёт: ${state.score}\nРекорд: ${best}\nНажми R, чтобы сыграть снова`, true); }
    }

    // ===== Render =====
    drawDungeon();

    // Player
    ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(player.angle); ctx.fillStyle=C.p1; ctx.strokeStyle=C.ink; ctx.lineWidth=4; roundRect(-14,-12, 28, 24, 10); ctx.fill(); ctx.stroke(); roundRect(6,-10, 18, 20, 8); ctx.fillStyle='#d9edff'; ctx.fill(); ctx.stroke(); ctx.fillStyle=C.visor; roundRect(9,-5, 12, 10, 5); ctx.fill(); ctx.stroke(); ctx.fillStyle=C.pistol; ctx.strokeStyle=C.ink; capsule(10,-3, 26, 4, 0); ctx.fill(); ctx.stroke(); ctx.restore();

    // Crosshair
    const aimX = player.x + Math.cos(player.angle)*32, aimY = player.y + Math.sin(player.angle)*32; ctx.strokeStyle=C.white; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(aimX, aimY, 10, 0, TAU); ctx.stroke();

    // bullets, enemies, boss
    bullets.forEach(b=>b.draw()); enemies.forEach(e=>e.draw()); if (boss) boss.draw(); xpDrops.forEach(o=>o.draw());

    // particles
    particles.forEach(p=>p.update(dt/1000)); for (let i=particles.length-1;i>=0;i--){ const p=particles[i]; if (p.life<=0) particles.splice(i,1); else p.draw(); }

    updateHud();
    requestAnimationFrame(frame);
  }

  // ===== Switching & restart (layout‑independent) =====
  window.addEventListener('keydown', (e)=>{
    if (e.code==='Digit1'||e.code==='Digit2'||e.code==='Digit3'||e.code==='Digit4'){ player.weaponIdx = parseInt(e.code.slice(-1))-1; renderWeaponList(); }
    if (e.code==='KeyQ'){ player.weaponIdx = (player.weaponIdx - 1 + weapons.length)%weapons.length; renderWeaponList(); }
    if (e.code==='KeyE'){ player.weaponIdx = (player.weaponIdx + 1)%weapons.length; renderWeaponList(); }
    if (e.code==='KeyR' && player.hp<=0){ restart(); }
  });
  function restart(){ bullets.length=0; enemies.length=0; particles.length=0; xpDrops.length=0; state.time=0; state.score=0; state.lastSpawn=0; state.roomId=0; state.xp=0; state.level=1; state.nextXp=50; player.hp=player.maxHp; player.x=canvas.clientWidth/2; player.y=canvas.clientHeight/2; player.dashCd=0; player.iTimer=0; state.running=true; setTip(''); startNewRoom(); }

  // ===== Boot sequence =====
  resize();    // ensure geometry exists
  startNewRoom();
  requestAnimationFrame(frame);

  // ===== Minimal & Added Tests =====
  function setTestStatus(msg, ok=true){
    if (!msg){ testStatus.style.display='none'; testStatus.textContent=''; return; }
    testStatus.style.display='block';
    testStatus.textContent = (ok? '✅ ':'❌ ') + msg;
    testStatus.style.borderColor = ok? '#2a2f3a' : '#a33';
  }
  function assert(cond, msg){ if(!cond) throw new Error(msg); }
  function runTests(){
    try {
      // UI & dungeon
      assert(hpFill && hpValue && coinsText && timeText && dashFill && centerTip && weaponList && waveText, 'UI elements missing');
      assert(Array.isArray(dungeon.rim) && dungeon.rim.length>0, 'Dungeon geometry not built');
      assert(roomTypes.length===5, 'Room must have exactly 5 enemy types');
      assert(enemies.length>=1, 'Enemies should spawn at room start');

      // Shooting basic
      const prev = bullets.length; const prevLast = player.lastShot; player.angle = 0; tryShoot(now()+1000, true); assert(bullets.length>prev, 'tryShoot should create a bullet'); player.lastShot = prevLast;

      // Assist picks nearest target
      const saveEnemies = enemies.slice();
      enemies.length = 0; // isolate
      const near = new Enemy(player.x+180, player.y+0, 'chaser');
      const far  = new Enemy(player.x+160, player.y+140, 'chaser');
      enemies.push(near, far);
      player.angle = Math.PI/2; // looking away – shouldn't matter for nearest mode
      let res = computeAssist(player.angle, weapons[0]); assert(res && res.lockId===near.id, 'Assist should pick NEAREST enemy');

      // Boss should be targetable
      const savedBoss = boss; const savedBossFlag = state.bossActive;
      boss = new Boss(); state.bossActive = true; enemies.length = 0;
      boss.x = player.x + 240; boss.y = player.y; boss.vx=0; boss.vy=0;
      res = computeAssist(player.angle, weapons[0]);
      assert(res && res.lockId==='boss', 'Assist should target BOSS when present');

      // Predictive lead: moving target produces changed angle
      enemies.length = 0; const mover = new Enemy(player.x+220, player.y, 'chaser'); mover.vx=0; mover.vy=120; enemies.push(mover);
      player.angle = 0;
      const leadRes = computeAssist(player.angle, weapons[2]);
      assert(leadRes, 'Assist should find moving target');
      const straightAng = Math.atan2(mover.y-player.y, mover.x-player.x);
      assert(angDiff(leadRes.leadAngle, straightAng) > 0.02, 'Lead angle should differ from straight line');

      // Movement sanity: pressing W moves up on a single 16ms tick
      const py = player.y; const vyBefore = player.vy; codes.add('KeyW'); let tdt=16; // simulate one frame
      // emulate one step of the new movement to avoid depending on frame loop
      let ix=0,iy=0; if(codes.has('KeyW')) iy-=1; let mag=Math.hypot(ix,iy); if(mag>0){ ix/=mag; iy/=mag; }
      const targetVy = iy * player.speed; const ay = targetVy - vyBefore; const maxStep = player.accel * (tdt/1000); let vyAfter = vyBefore; if (Math.hypot(0,ay)>maxStep) vyAfter += (ay/Math.abs(ay))*maxStep; else vyAfter = targetVy; const yAfter = py + vyAfter*tdt/1000; assert(yAfter < py, 'Pressing W should move player up'); codes.delete('KeyW');

      // Dash direction test: should dash along movement, not view
      const oldX = player.x, oldY = player.y; player.dashCd = 0; player.angle = Math.PI/2; // looking up
      codes.add('KeyD'); // moving right
      doDash(200); // shorter dash for test
      assert(player.x > oldX && Math.abs(player.y-oldY) < 2, 'Dash must go to movement direction (right)');
      codes.delete('KeyD');

      // Instant aim test: angle snaps to computed target immediately
      enemies.length = 0; const e = new Enemy(player.x+200, player.y, 'chaser'); enemies.push(e);
      player.angle = Math.PI/2; // wrong angle
      applyAimAssistInstant();
      const snapRes = computeAssist(0, weapons[player.weaponIdx]);
      const targetAng = angleLerp(snapRes.straightAngle, snapRes.leadAngle, settings.assistLeadFactor);
      assert(angDiff(player.angle, targetAng) < 1e-3, 'Aim angle must snap instantly without smoothing');

      // Shot uses exact snapped angle (no blend)
      const oldSpread = weapons[player.weaponIdx].spread; weapons[player.weaponIdx].spread = 0;
      const bulletsBefore = bullets.length; player.lastShot=0; tryShoot(now()+2000, true);
      assert(bullets.length > bulletsBefore, 'Bullet should be created');
      const b = bullets[bullets.length-1];
      const bAng = Math.atan2(b.vy, b.vx);
      assert(angDiff(bAng, targetAng) < 1e-2, 'Bullet angle should equal target aim (no smoothing)');
      weapons[player.weaponIdx].spread = oldSpread;

      // Auto-fire on boss only scenario
      enemies.length = 0; bullets.length = 0; player.lastShot=0; boss.x = player.x + 260; boss.y = player.y; settings.autoFire = true;
      const beforeAuto = bullets.length; const testNow = now()+2500; // emulate next time
      // simulate frame auto-fire logic
      const af = computeAssist(player.angle, weapons[player.weaponIdx]); if (af) tryShoot(testNow, true);
      assert(bullets.length > beforeAuto, 'Auto-fire should shoot at boss');

      // restore boss flag
      boss = savedBoss; state.bossActive = savedBossFlag;

      // Restore enemies
      enemies.length = 0; for(const x of saveEnemies) enemies.push(x);

      setTestStatus('');
    } catch(e){
      console.error('[TEST FAIL]', e); setTestStatus(e.message, false);
    }
  }
  setTimeout(runTests, 50);
})();
</script>
</body>
</html>
